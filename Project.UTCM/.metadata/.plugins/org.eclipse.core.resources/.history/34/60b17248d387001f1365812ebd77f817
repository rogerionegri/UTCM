function best_bouding_boxes, data, maxK

  seed = 1234567L
  rep = 10000L

  BS = 0.5*__IQR(data)*(N_ELEMENTS(data)^(-1.0/3.0)) ;Freedman-Diaconis' rule
  y = HISTOGRAM(data, BINSIZE=BS, LOCATIONS = x)
  
  
  ;Remove extreme values---------------
  z = total(y,/cumulative)/total(y)
  posInf = where(z lt 0.01)
  posSup = where(z gt 0.99)
  y = y[posInf[-1]:posSup[0]]
  x = x[posInf[-1]:posSup[0]]
  ;------------------------------------
  
  
  nx = n_elements(x)
  dx = x[1]-x[0]
  
  diagGeral = sqrt( (max(x) - min(x))^2 + (max(y) - min(y))^2 )

  
  ;sentinelPos = 10D^100
  sentinelPos = 0  
  sentinelCost = (max(y) * (x[-1] - x[0])) - total(y*dx)  ;sem divisão...
  vecStructBox = [ptr_new({lims: [min(x), max(x)], minCost: sentinelCost, bestConf: [0,n_elements(x)-1]})]
  
  percImprove = 1.0
  
  vecMinCost =  fltarr(maxK+1)
  
  vecMinCost[0] = sentinelCost
  for k = 1, maxK do begin

    cost = dblarr(rep)
    conf = intarr(k+2,rep)

    for r = 0, rep-1 do begin
      
      rnd = sort(randomu(seed,nx))
      conf[*,r] = [0, rnd(sort(rnd[0:k-1])), nx-1]  ;represents the partition configuration

      penaltyDiag = 0
      for i = 0, k do begin
        BOX = max(y[conf[i,r]:conf[i+1,r]]) * (x[conf[i+1,r]] - x[conf[i,r]])
        ;LIN = (x[conf[i+1,r]] - x[conf[i,r]])
        ;AUF = total( y[conf[i,r]:conf[i+1,r]]*x[conf[i,r]:conf[i+1,r]] )
        AUF = total( y[conf[i,r]:conf[i+1,r]]*dx )
        ;cost[r] += (BOX/AUF);*k
        ;cost[r] += (LIN/AUF);*k
        cost[r] += (BOX - AUF)
        ;cost[r] += (AUF/BOX)
        ;penaltyDiag += sqrt( (x[conf[i+1,r]] - x[conf[i,r]])^2 + max(y[conf[i,r]:conf[i+1,r]])^2 )
      endfor
      ;cost[r] *= (penaltyDiag/diagGeral)
      ;cost[r] /= k
      
    endfor

    vecMinCost[k] = min(cost)

    minPos = where(cost eq min(cost))
    bestConf = conf[*,minPos[0]]
    
    ;maxPos = where(cost eq max(cost))
    ;bestConf = conf[*,maxPos[0]]

    lims = x[bestConf] ;disregards the inf/sup limits

    vecStructBox = [vecStructBox , ptr_new({lims: lims, minCost: min(cost), bestConf: bestConf})]

    ;if sentinelCost lt min(cost) then begin
    ;if sentinelCost gt (k+1)*min(cost) then begin
      ;if sentinelCost gt sqrt(k+1)*min(cost) then begin
    ;if sentinelCost gt k*min(cost) then begin
    ;if sentinelCost gt sqrt(k)*min(cost) then begin
    
    if sentinelCost gt sqrt(k)*min(cost) then begin  
      sentinelCost = min(cost)
      sentinelPos = k
    endif

  endfor

  for i = 0, n_elements(vecStructBox)-1 do print, *vecStructBox[i]

  best = *vecStructBox[sentinelPos]
  bestFoundBox = best.lims
  cutPoint = mean(bestFoundBox[1:-2])

  midPoints = fltarr(n_elements(bestFoundBox)-1)
  for i = 0, n_elements(bestFoundBox)-2 do midPoints[i] = (bestFoundBox[i] + bestFoundBox[i+1])*0.5 

  return, {vecStructBox: vecStructBox, bestFoundBox: bestFoundBox, bestBox: best, x: x, midPoints: midPoints, cutPoint: cutPoint}
end



;========================================
;========================================
;========================================
;Implementation -- 27jun23
function best_bouding_box, data

  k = 1
  seed = 1234567L
  rep = 10000L

  BS = 0.5*__IQR(data)*(N_ELEMENTS(data)^(-1.0/3.0)) ;freedman-diaconis rule
  ;BS = 3.49*STDDEV(data)*(N_ELEMENTS(data)^(-1.0/3))
  y = HISTOGRAM(data, BINSIZE=BS, LOCATIONS = x)

  ;Remove extreme values---------------
  z = total(y,/cumulative)/total(y)
  posInf = where(z lt 0.01) & if posInf[0] eq -1 then posInf[0] = 0 
  posSup = where(z gt 0.99) & if posSup[0] eq -1 then posSup[0] = n_elements(z)-1
  y = y[posInf[-1]:posSup[0]]
  x = x[posInf[-1]:posSup[0]]
  ;------------------------------------

  nx = n_elements(x)
  dx = x[1]-x[0]

  ;sentinelPos = 10D^100
  sentinelPos = 0
  sentinelCost = (max(y) * (x[-1] - x[0])) - total(y*dx)  ;sem divisão...
  ;vecStructBox = [ptr_new({lims: [min(x), max(x)], minCost: sentinelCost, bestConf: [0,n_elements(x)-1]})]

  cost = dblarr(rep)
  conf = lonarr(k+2,rep)

  for r = 0, rep-1 do begin

    rnd = sort(randomu(seed,nx))
    conf[*,r] = [0, rnd(sort(rnd[0:k-1])), nx-1]  ;represents the partition configuration

    penaltyDiag = 0
    for i = 0, k do begin
      BOX = max(y[conf[i,r]:conf[i+1,r]]) * (x[conf[i+1,r]] - x[conf[i,r]])
      AUF = total( y[conf[i,r]:conf[i+1,r]]*dx )
      cost[r] += (BOX - AUF)
    endfor

  endfor

  minPos = where(cost eq min(cost))
  bestConf = conf[*,minPos[0]]
  lims = x[bestConf] ;disregards the inf/sup limits

  midPoints = fltarr(n_elements(bestConf)-1)
  for i = 0, n_elements(bestConf)-2 do midPoints[i] = (bestConf[i] + bestConf[i+1])*0.5

  return, {bestConf: bestConf, lims: lims, midPoints: midPoints}  ;vecStructBox: vecStructBox, bestFoundBox: bestFoundBox, bestBox: best, x: x, midPoints: midPoints}
  ;return, {vecStructBox: vecStructBox, bestFoundBox: bestFoundBox, bestBox: best, x: x, midPoints: midPoints}
end


;vecStructBox = [vecStructBox , ptr_new({lims: lims, minCost: min(cost), bestConf: bestConf})]


;if sentinelCost gt sqrt(k+1)*min(cost) then begin
;  sentinelCost = min(cost)
;  sentinelPos = k
;endif


;for i = 0, n_elements(vecStructBox)-1 do print, *vecStructBox[i]
;
;best = *vecStructBox[sentinelPos]
;bestFoundBox = best.lims
;
;midPoints = fltarr(n_elements(bestFoundBox)-1)
;for i = 0, n_elements(bestFoundBox)-2 do midPoints[i] = (bestFoundBox[i] + bestFoundBox[i+1])*0.5
