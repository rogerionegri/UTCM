;-----------------------------------------
FUNCTION PCA_AXIS, Samples
  dims = SIZE(Samples, /DIMENSIONS)

  Psi = DBLARR(dims[0])  ;Mean Vector
  FOR i = 0, dims[0]-1 DO Psi[i] = MEAN(Samples[i,*])

  Sigm = DBLARR(dims[0], dims[0]) ;Covariance Matrix
  FOR i = 0, dims[1]-1 DO Sigm[*,*] +=  (Samples[*,i] - Psi[*]) # (Samples[*,i] - Psi[*])
  Sigm =  (1.0/dims[1])*Sigm

  eval = EIGENQL(Sigm, EIGENVECTORS = evec, RESIDUAL = residual)

  sortEVal = REVERSE(SORT(eval))
  pcaEigVecMatrix = Sigm*0D

  ;Sort the covariance matrix according the most relevant eigenvalues
  FOR i = 0, N_ELEMENTS(sortEVal)-1 DO pcaEigVecMatrix[*,i] = evec[*,sortEVal[i]]

  Return, {eivec: pcaEigVecMatrix, eival: eval[sortEVal], mu: psi, sigm: Sigm}
END





;
;
;FUNCTION PCA_AXIS__original, img
;
;  sampleBlocks = GET_SAMPLE_VECTOR(img)
;  Psi = COMPUTE_MEAN_VECTOR(sampleBlocks)
;  Sigm = COMPUTE_COV_MATRIX(sampleBlocks)
;
;  eval = EIGENQL(Sigm, EIGENVECTORS = evec, RESIDUAL = residual)
;
;  sortEVal = REVERSE(SORT(eval))
;  pcaEigVecMatrix = Sigm*0D
;
;  ;ordenar a matriz de confusao de acordo com o autovalor mais relevante
;  FOR i = 0, N_ELEMENTS(sortEVal)-1 DO pcaEigVecMatrix[*,i] = evec[*,sortEVal[i]]
;
;  ;fazer a projecao da informaçao para o espaço pca
;  ;projPCA = PROJECTION_PCA_SPACE(difImage, Psi, pcaEigVecMatrix, h)
;
;  Return, pcaEigVecMatrix
;END
;
;
;FUNCTION PCA_AXIS_III, img
;
;  sampleBlocks = GET_SAMPLE_VECTOR(img)
;  Psi = COMPUTE_MEAN_VECTOR(sampleBlocks)
;  Sigm = COMPUTE_COV_MATRIX(sampleBlocks)
;
;  eval = EIGENQL(Sigm, EIGENVECTORS = evec, RESIDUAL = residual)
;
;  sortEVal = REVERSE(SORT(eval))
;  pcaEigVecMatrix = Sigm*0D
;
;  ;ordenar a matriz de confusao de acordo com o autovalor mais relevante
;  FOR i = 0, N_ELEMENTS(sortEVal)-1 DO pcaEigVecMatrix[*,i] = evec[*,sortEVal[i]]
;
;  ;fazer a projecao da informaçao para o espaço pca
;  ;projPCA = PROJECTION_PCA_SPACE(difImage, Psi, pcaEigVecMatrix, h)
;
;  Return, pcaEigVecMatrix
;END
;
;
;;-----------------------------------------
;FUNCTION PCA_AXIS_II, img
;
;  sampleBlocks = GET_SAMPLE_VECTOR(img)
;  Psi = COMPUTE_MEAN_VECTOR(sampleBlocks)
;  Sigm = COMPUTE_COV_MATRIX(sampleBlocks)
;
;  eval = EIGENQL(Sigm, EIGENVECTORS = evec, RESIDUAL = residual)
;
;  sortEVal = REVERSE(SORT(eval))
;  pcaEigVecMatrix = Sigm*0D
;
;  ;ordenar a matriz de confusao de acordo com o autovalor mais relevante
;  FOR i = 0, N_ELEMENTS(sortEVal)-1 DO pcaEigVecMatrix[*,i] = evec[*,sortEVal[i]]
;
;  ;fazer a projecao da informaçao para o espaço pca
;  ;projPCA = PROJECTION_PCA_SPACE(difImage, Psi, pcaEigVecMatrix, h)
;
;  Return, {eivec: pcaEigVecMatrix, eival: eval[sortEVal]}
;END
;
;
;
;;------------------------------------------
;function GET_SAMPLE_VECTOR, img
;  nb = n_elements(img[*,0,0])
;  nc = n_elements(img[0,*,0])
;  nl = n_elements(img[0,0,*])
;  
;  vec = fltarr(nb,nc*nl)
;  ind = 0L
;  for i = 0, nc-1 do begin
;    for j = 0, nl-1 do begin
;      vec[*,ind] = img[*,i,j]
;      ind++
;    endfor
;  endfor
;
;  return, vec
;end
;
;
;
;;------------------------------------------
;FUNCTION COMPUTE_MEAN_VECTOR, Samples
;  dims = SIZE(Samples, /DIMENSIONS)
;
;  avgVec = DBLARR(dims[0])
;  FOR i = 0, dims[0]-1 DO avgVec[i] = MEAN(Samples[i,*])
;
;  Return, avgVec
;END
;
;
;;----------------------------------------
;FUNCTION COMPUTE_COV_MATRIX, Samples
;
;  dims = SIZE(Samples, /DIMENSIONS)
;  Psi = COMPUTE_MEAN_VECTOR(Samples)
;
;  C = DBLARR(dims[0], dims[0])
;  FOR i = 0, dims[1]-1 DO C[*,*] +=  (Samples[*,i] - Psi[*]) # (Samples[*,i] - Psi[*])
;
;  C =  (1.0/dims[1])*C
;
;  Return, C
;END
;
;
;
;;------------------------------------------
;FUNCTION PCA_POJECTION, Img, Psi, sortC, h
;
;
;  dims = GET_DIMENSIONS(Img)
;
;  projImg = DBLARR(N_ELEMENTS(Psi), dims[1], dims[2])
;
;  FOR i = 0, dims[1]-1 DO BEGIN
;    FOR j = 0, dims[2]-1 DO BEGIN
;
;      IF ((i - h/2) GE 0) AND ((i + h/2) LT dims[1]) AND ((j - h/2) GE 0) AND ((j + h/2) LT dims[2]) THEN BEGIN
;        x = GET_VECTOR_NEIGH(Img, i, j, h)
;        Vs = transpose(sortC)#(x - Psi)
;
;        projImg[*,i,j] = Vs
;      ENDIF
;
;    ENDFOR
;  ENDFOR
;
;  Return, projImg
;END